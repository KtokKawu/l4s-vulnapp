<#	.SYNOPSIS		This script activate a server that receives and displays binary communications in order to detect Log4Shell.	.DESCRIPTION		Notes:			This script  activate a server, execute this script on Windows PowerShell/Command Prompt.			This server receives binary communications such as LDAP and RMI,			and can display the contents of said communications in Hex and Raw.			Basically, the server stops after receiving the binary communication and displaying the log,			but if the script malfunctions, use Ctrl + C to stop it.		Caution:			When running this script for the first time, it is necessary to select "Private Network" in the Windows pop-up.	.EXAMPLE		PowerShell -ExecutionPolicy RemoteSigned .\l4s-ls.ps1 -p 8081 -l C:\Users\test\Desktop\20240315_01_l4s.log	.EXAMPLE		PowerShell -ExecutionPolicy RemoteSigned Get-Help .\l4s-ls.ps1	.PARAMETER -p,-port		Specify the port of the listening server.	.PARAMETER -l,-logpath		Specify where to output the script execution log.#>Param(    [alias("p")][int]$port,    [alias("l")][string]$logpath)if([string]::IsNullOrEmpty($logpath)) {    $date = Get-Date -Format "yyyyMMddHHmmss";    $logpath = Join-Path .\ ($date + "_l4s.log")}$ErrorActionPreference = "Stop"function getLog($output){    if([string]::IsNullOrEmpty($output)) {        Out-file -FilePath $logpath -InputObject "$(Get-Date -Format "yyyy/MM/dd HH:mm:ss"):" -append    } else {        Write-Output $output        Write-Output "$(Get-Date -Format "yyyy/MM/dd HH:mm:ss"): $output" | Out-file -FilePath $logpath -append    }}function stopServ(){    $client.Close()    $listener.Stop()    Write-Output ""    getLog("[Stop] Recieve Server.")    exit}function interact($client) {    $stream = $client.GetStream()    $buffer = New-Object System.Byte[] $client.ReceiveBufferSize    $enc = New-Object System.Text.AsciiEncoding    try {        $ar = $stream.BeginRead($buffer, 0, $buffer.length, $NULL, $NULL)        while ($TRUE) {            if ($ar.IsCompleted) {                $bytes = $stream.EndRead($ar)                if ($bytes -eq 0) { break }                                Write-Output ""                getLog("[Hex data] ===== start =====")                Write-Output ($buffer | fhx )[0..1] | ForEach-Object{ getLog(Write-Output $_) }                getLog("[Hex data] =====  end  =====")                                Write-Output ""                getLog("[Raw data] ===== start =====")                getLog(Write-Output $enc.GetString($buffer, 0, $bytes))                getLog("[Raw data] =====  end  =====")                $ar = $stream.BeginRead($buffer, 0, $buffer.length, $NULL, $NULL)            }            Write-Output "`r`n[Note] Log4Shell outbound communication successfully caught."            stopServ($NULL)        }    } catch [System.IO.IOException] {        getLog("[Error] Occured System.IO.IOException.")        stopServ($NULL)    } finally {        $stream.Close()    }}getLog("[Start] Receive Server for Log4Shell.")Write-Output "`r`n[Note] Wait for Log4Shell outbound communication to be received..."$endpoint = New-Object System.Net.IPEndPoint ([System.Net.IPAddress]::Any, $port)$listener = New-Object System.Net.Sockets.TcpListener $endpoint$listener.Start()getLog("[Note] Listening on IP: `"localhost`" Port: $($port)")$handle = $listener.BeginAcceptTcpClient($NULL, $NULL)while (!$handle.IsCompleted) {    Start-Sleep -m 100}$client = $listener.EndAcceptTcpClient($handle)$remote = $client.Client.RemoteEndPointWrite-Output ""getLog("[Note] Requested from IP: `"$($remote.Address)`" Port: $($remote.Port))")interact $client